{% extends 'base.html' %}

{% block main %}

{% include 'actionbar.html' %}
<link rel="stylesheet" href="{{ url_for('static', filename='libs/mobile-drag-drop/release/default.css') }}">
<script src="{{ url_for('static', filename='libs/mobile-drag-drop/release/index.min.js') }}"></script>
<script src="{{ url_for('static', filename='libs/progressbar.js/dist/progressbar.min.js') }}"></script>

<div id="ask_dialog" style="display: none;">
    <p>
        <span class="ui-icon ui-icon-alert" style="float:left; margin:12px 12px 20px 0;"></span>
        <span></span>
    </p>
    <div>
        <input type="checkbox" id="dontask_cb">
        <label for="dontask_cb">Don't ask again</label>
    </div>
</div>

<div id="alert_dialog" style="display: none;">
    <p>
        <span class="ui-icon ui-icon-alert" style="float: left; margin: 12px 12px 20px 0;"></span>
        <span></span>
    </p>
</div>

<script>
let MAX_UPLAOAD_SIZE = {{ config.MAX_UPLOAD_SIZE | tojson }};

MobileDragDrop.polyfill({
    iterationInterval: 100,
});

let treeview = new Treeview({
    draggable: true,
    droppable: true,
    root_folder: 'Root',
    file_drop: true,
});
$('#content').append(treeview.html);
treeview.select_handler = (selection) => {
    console.log('treeview', 'select', selection);
}
treeview.dblclick_handler = (path, shift) => {
    console.log('treeview', 'dblclick', path, shift);
};
treeview.drop_handler = (data, path) => {
    if (data.type == 'items') {
        async function ask(title, message) {
            let state = false;
            let canceled = true;
            let defer = $.Deferred();
            let $dialog = $('#ask_dialog');
            $dialog.find('span:nth-of-type(2)').html(message);
            $('#dontask_cb').prop('checked', false);
            let dialog = $dialog.dialog({
                resizable: false,
                title: title,
                height: "auto",
                width: 400,
                modal: true,
                close: () => {
                    defer.resolve([state,
                        !canceled && $('#dontask_cb').is(':checked')]);
                },
                buttons: {
                    No: () => {
                        canceled = false;
                        state = false;
                        dialog.dialog('close');
                    },
                    Yes: () => {
                        canceled = false;
                        state = true;
                        dialog.dialog('close');
                    },
                },
            });
            return defer.promise();
        }

        async function alert(title, message) {
            let defer = $.Deferred();
            let $dialog = $('#alert_dialog');
            $dialog.find('span:nth-of-type(2)').html(message);
            let dialog = $dialog.dialog({
                resizable: false,
                title: title,
                height: "auto",
                width: 400,
                modal: true,
                close: () => defer.resolve(),
                buttons: {
                    OK: () => dialog.dialog('close'),
                },
            });
            return defer.promise();
        }

        async function upload_handler() {
            let entries = await getAllEntries(data.source_items);
            let merge, merge_dontask = false;
            let overwrite, overwrite_dontask = false;

            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let path = data.dest_node.path + entry.fullPath.slice(1);
                if (entry.isDirectory) {
                    path += '/';
                }
                let exists = data.dest_node.tree.exists(path);
                if (exists && entry.isDirectory) {
                    if (!merge_dontask) {
                        [merge, merge_dontask] = await ask('Merge folders?', 
                            'The folder <b>' + path + '</b> already exists. '
                            + 'Do you wish to merge?');
                    }
                    if (!merge) {
                        entries = entries.filter(e =>
                            !e.fullPath.startsWith(entry.fullPath));
                    }
                } else if (entry.isFile) {
                    if (exists) {
                        if (!overwrite_dontask) {
                            [overwrite, overwrite_dontask] = await ask(
                                'Overwrite?', 'The file <b>' + path + '</b> '
                                + 'already exists. Overwrite?');
                        }
                        if (!overwrite) {
                            continue;
                        }
                    }
                    let root = path.match(/(.+\/)?[^\/]*/)[1] || '';
                    let file = await getFilePromise(entry);
                    if (file.size <= MAX_UPLAOAD_SIZE) {
                        new TreeviewUpload(file, root, data.dest_node);
                    } else {
                        console.log(file.name);
                        await alert('File too big', 'The file <b>'
                            + root + file.name + '</b> is too big and '
                            + 'will not be uploaded.');
                    }
                }
            }
        }
        upload_handler();
    } else if (data.type == 'local') {
        let url = new URL(window.location);
        let search = new URLSearchParams();
        search.set('action', data.shift ? 'copy' : 'move');
        url.search = search;
        let fd = new FormData();
        fd.append('dest', data.dest_node.path);
        data.selected_parents.forEach(node => fd.append('paths', node.path));
        $.post({
            url: url,
            data: fd,
            processData: false,
            contentType: false,
            success: (json) => {
                if (!data.shift) {
                    data.source_node.$li.trigger('dragend');
                }
                for (let node of data.selected_parents) {
                    [_, paths] = data.source_node.tree.list(node);
                    paths.forEach(path =>
                        data.dest_node.tree.insert(data.dest_node.path + path));
                    if (!data.shift) {
                        data.source_node.tree.remove(node);
                    }
                }
            },
        });
    }
};

let url = new URL(window.location);
let search = new URLSearchParams();
search.set('action', 'list');
url.search = search;
$.get(url, data => {
    data.paths.forEach(path => {
        let node = treeview.insert(path);
        node.exists = true;
    });
});

</script>
{% endblock %}