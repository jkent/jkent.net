{% extends 'base.html' %}

{% block main %}

{% include 'actionbar.html' %}
<link rel="stylesheet" href="{{ url_for('static', filename='libs/mobile-drag-drop/release/default.css') }}">
<script src="{{ url_for('static', filename='libs/mobile-drag-drop/release/index.min.js') }}"></script>
<script src="{{ url_for('static', filename='libs/progressbar.js/dist/progressbar.min.js') }}"></script>

<div id="ask_dialog" style="display: none;">
    <p>
        <span class="ui-icon ui-icon-alert" style="float:left; margin:12px 12px 20px 0;"></span>
        <span></span>
    </p>
    <div>
        <input type="checkbox" id="dontask_cb">
        <label for="dontask_cb">Don't ask again</label>
    </div>
</div>

<div id="alert_dialog" style="display: none;">
    <p>
        <span class="ui-icon ui-icon-alert" style="float: left; margin: 12px 12px 20px 0;"></span>
        <span></span>
    </p>
</div>

<script>
let MAX_UPLAOAD_SIZE = {{ config.MAX_UPLOAD_SIZE | tojson }};

MobileDragDrop.polyfill({
    iterationInterval: 100,
});

let treeview = new Treeview({
    draggable: true,
    droppable: true,
    root_folder: 'Root',
    file_drop: true,
});
$('#content').append(treeview.html);
/*treeview.select_handler = (selection) => {
    console.log('treeview', 'select', selection);
};
treeview.dblclick_handler = (path, shift) => {
    console.log('treeview', 'dblclick', path, shift);
};*/
treeview.drop_handler = (data, path) => {
    if (data.type == 'items') {
        async function upload_handler() {
            let entries = await getAllEntries(data.source_items);
            let merge, merge_dontask = false;
            let overwrite, overwrite_dontask = false;

            for (let i = 0; i < entries.length; i++) {
                let entry = entries[i];
                let path = data.dest_node.path + entry.fullPath.slice(1);
                if (entry.isDirectory) {
                    path += '/';
                }
                let exists = data.dest_node.tree.exists(path);
                if (exists && entry.isDirectory) {
                    if (!merge_dontask) {
                        [merge, merge_dontask] = await ask('Merge folders?', 
                            'The folder <b>' + path + '</b> already exists. '
                            + 'Do you wish to merge?');
                    }
                    if (!merge) {
                        entries = entries.filter(e =>
                            !e.fullPath.startsWith(entry.fullPath));
                    }
                } else if (entry.isFile) {
                    if (exists) {
                        if (!overwrite_dontask) {
                            [overwrite, overwrite_dontask] = await ask(
                                'Overwrite?', 'The file <b>' + path + '</b> '
                                + 'already exists. Overwrite?');
                        }
                        if (!overwrite) {
                            continue;
                        }
                    }
                    let root = path.match(/(.+\/)?[^\/]*/)[1] || '';
                    let file = await getFilePromise(entry);
                    if (file.size <= MAX_UPLAOAD_SIZE) {
                        new TreeviewUpload(file, root, data.dest_node);
                    } else {
                        await alert('File too big', 'The file <b>'
                            + root + file.name + '</b> is too big and '
                            + 'will not be uploaded.');
                    }
                }
            }
        }
        upload_handler();
    } else if (data.type == 'local') {
        let merge = true, merge_dontask = false;
        let overwrite = true, overwrite_dontask = false;

        async function collect_rules(src_nodes, dest_node, move) {
            let found = false;
            let rules = [];
            let rmtree = move;

            for (let src_node of src_nodes) {
                found = false;
                for (let child of dest_node.children) {
                    if (src_node.name == child.name) {
                        found = true;
                        if (src_node.type == 'folder') {
                            if (!merge_dontask) {
                                [merge, merge_dontask] = await ask('Merge '
                                    + 'folders?', 'The folder <b>' + child.path
                                    + '</b> already exists. Do you wish to '
                                    + 'merge?');
                            }
                            if (merge) {
                                let [subrules, rmtree] =
                                    await collect_rules(src_node.children,
                                                        child, move);
                                rules.push(...subrules);
                            } else {
                                rmtree = false;
                            }
                        } else if (src_node.type == 'file') {
                            if (!overwrite_dontask) {
                                [overwrite, overwrite_dontask] = await ask(
                                    'Overwrite?', 'The ' + child.type + ' <b>'
                                    + child.path + '</b> already exists. '
                                    + 'Overwrite?');
                            }
                            if (overwrite) {
                                rules.push({
                                    'op': move ? 'mv' : 'cp',
                                    'from': src_node.path,
                                    'to': child.path,
                                });
                            } else {
                                rmtree = false;
                            }
                        }
                    }
                }
                if (!found) {
                    rules.push({
                        'op': move ? 'mv' : 'cp',
                        'from': src_node.path,
                        'to': dest_node.path,
                    });
                }
                if (src_node.type == 'folder' && rmtree) {
                    rules.push({
                        'op': 'rmtree',
                        'path': src_node.path,
                    });
                }
            }
            return [rules, rmtree];
        }

        async function dnd_handler() {
            let [rules] = await collect_rules(data.selected_parents,
                                              data.dest_node, !data.shift);
            let url = new URL(window.location);
            let search = new URLSearchParams();
            search.set('action', 'dnd');
            url.search = search;
            $.post({
                url: url,
                data: JSON.stringify({'rules': rules}),
                contentType: 'application/json',
                success: (json) => {
                    if (!json.success) {
                        return;
                    }
                    for (let rule of rules) {
                        if (rule.op == 'cp' || rule.op == 'mv') {
                            function copy(from_node, to_path) {
                                let dest_node;
                                if (from_node.type == 'folder') {
                                    if (!to_path.endsWith('/')) {
                                        to_path += '/';
                                    }
                                    data.dest_node.tree.insert(to_path);
                                    for (let child of from_node.children.slice()) {
                                        copy(child, to_path + child.name);
                                    }
                                } else {
                                    let node = data.source_node.tree.find(to_path);
                                    if (node && node.type == 'folder') {
                                        to_path += from_node.name;
                                    }
                                    data.dest_node.tree.insert(to_path);
                                    if (rule.op == 'mv') {
                                        data.source_node.tree.remove(from_node);
                                    }
                                }
                            }
                            let from_node = data.source_node.tree.find(rule.from);
                            let to_path = rule.to;
                            if (from_node.type == 'folder') {
                                to_path += from_node.name;
                            }
                            copy(from_node, to_path);
                            data.dest_node.$ul.slideDown(200);
                        }
                        if (rule.op == 'rmtree') {
                            data.source_node.tree.remove(rule.path);
                        }
                    }
                },
            });
        }
        dnd_handler();
    }
};
treeview.rename_handler = (node, name) => {
    name = name.trim();
    let url = new URL(window.location);
    let search = new URLSearchParams();
    search.set('action', 'rename');
    url.search = search;
    $.post({
        url: url,
        data: JSON.stringify({'path': node.path, 'name': name}),
        contentType: 'application/json',
        success: (json) => {
            node.tree.rename(node, json.name);
            /* rebuild tree */
        },
        error: () => {
            node.tree.rename(node, null);
        },
    });
};

let url = new URL(window.location);
let search = new URLSearchParams();
search.set('action', 'list');
url.search = search;
$.get(url, data => {
    data.paths.forEach(path => {
        let node = treeview.insert(path);
        node.exists = true;
    });
});

</script>
{% endblock %}